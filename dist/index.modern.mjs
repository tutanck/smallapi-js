import t from"lodash";import e from"isarray";import r from"url-parse";import n from"remove-trailing-slash";import o from"axios";import{createInstance as s,makeGet as i,makePost as a,makePut as u,makeDel as c}from"@tutanck/axios";import l from"qs";const g="/api",d="/conf";function f(){return f=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)({}).hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},f.apply(null,arguments)}const y=o.create(),p=(t,e)=>y(f({method:"get",url:t},e)).then(t=>t.data).catch(t=>{throw t});async function h(o,{debug:s=!1}){return!0===s&&console.log("-> fetching",o),await p(o,{}).then(async i=>{let a;if(!function(t=[]){var e;const r=t.find(t=>(null==t?void 0:t.path)===d);return Boolean(null==r||null==(e=r.methods)?void 0:e.includes("GET"))}(i))throw new Error(`Api conf not found on server '${o}'`);try{const r=`${n(o)}${d}`;!0===s&&console.log("-> fetching",r);const i=await p(r,{}),{routing:u}=i,c=u[g];if(!(e(c)&&c.length>0))throw new Error("Invalid or empty api-map");a=t.groupBy(c,"name")}catch(t){throw console.error(t),new Error(`Api conf unreachable on server '${o}'`)}const{protocol:u,host:c}=r(o);return{descriptor:a,serverRootUrl:`${u}//${c}`,apiBaseUri:g}}).catch(t=>{throw console.error(t),new Error(`Unable to connect to server '${o}'`)})}async function $(t,{apiKey:e=null,decodeKey:r=null,debug:o=!1}){if(!t)throw new Error("'serverUrl' cannot be undefined or null.");!0===o&&console.log({serverUrl:t,apiKey:e,decodeKey:r,debug:o});const g=await h(t,{debug:o}),{descriptor:d,serverRootUrl:y,apiBaseUri:p}=g,$=function({serverRootUrl:t,apiBaseUri:e,apiKey:r,decodeKey:o}){const l=[n(t),e].join(""),g=s({baseURL:l,headers:{authorization:r}});return{get:i(g,{encryption:{decodeKey:o}}),post:a(g,{encryption:{decodeKey:o}}),put:u(g,{encryption:{decodeKey:o}}),del:c(g,{encryption:{decodeKey:o}})}}({serverRootUrl:y,apiBaseUri:p,decodeKey:r,apiKey:e}),{get:m,post:b,put:v,del:B}=$,w=function(t,{get:e,post:r,put:n,del:o},{debug:s=!1}){const i=Object.entries(t).reduce((t,[i,a])=>{const u=function(t){if(t.endsWith("Routine")){const e=t.substring(0,t.length-7),r="count";if(t.startsWith(r))return`count${e.substring(r.length,t.length)}`;const n="create";if(t.startsWith(n))return`create${e.substring(n.length,t.length)}`;const o="findById";if(t.startsWith(o))return`find${e.substring(o.length,t.length)}ById`;const s="findByQuery";if(t.startsWith(s))return`find${e.substring(s.length,t.length)}ByQuery`;const i="removeById";if(t.startsWith(i))return`remove${e.substring(i.length,t.length)}ByQuery`;const a="removeByQuery";if(t.startsWith(a))return`remove${e.substring(a.length,t.length)}ByQuery`;const u="updateById";if(t.startsWith(u))return`update${e.substring(u.length,t.length)}ById`;const c="updateByQuery";if(t.startsWith(c))return`update${e.substring(c.length,t.length)}ByQuery`}return t}(i),[c]=a,g=function({uri:t,name:e,verb:r},{get:n,post:o,put:s,del:i},{debug:a=!1,fnName:u}){const c={PUT:s,GET:n,POST:o,DELETE:i}[r];if(e.endsWith("Routine")){if(e.startsWith("count"))return async n=>{const o=`${t}?${l.stringify({filter:n})}`;return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${o}'`)),c(o)};if(e.startsWith("create"))return async(n,o={})=>{const s=`${t}?${l.stringify({options:o})}`,i={data:{docs:n}};return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${s}' with data: ${JSON.stringify(i)}`)),c(s,i)};if(e.startsWith("findById"))return async(n,o={},s={})=>{const i=`${t}${n}?${l.stringify({projection:o,options:s})}`;return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${i}'`)),c(i)};if(e.startsWith("findByQuery"))return async(n,o={},s={})=>{const i=`${t}?${l.stringify({filter:n,projection:o,options:s})}`;return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${i}'`)),c(i)};if(e.startsWith("removeById"))return async(n,o={})=>{const s=`${t}${n}?${l.stringify({options:o})}`;return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${s}'`)),c(s)};if(e.startsWith("removeByQuery"))return async(n,o={})=>{const s=`${t}?${l.stringify({filter:n,options:o})}`;return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${s}'`)),c(s)};if(e.startsWith("updateById"))return async(n,o,s={})=>{const i=`${t}${n}?${l.stringify({options:s})}`,g={data:{update:o}};return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${i}' with data: ${JSON.stringify(g)}`)),c(i,g)};if(e.startsWith("updateByQuery"))return async(n,o,s={})=>{const i=`${t}?${l.stringify({filter:n,options:s})}`,g={data:{update:o}};return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${i}' with data: ${JSON.stringify(g)}`)),c(i,g)}}return async({body:n,query:o,params:s})=>{const i=`${t}?${l.stringify({query:o})}`,g={data:n,params:s};return!0===a&&(console.log({fnName:u,uri:t,name:e,verb:r}),console.log(`${r} '${i}' with data: ${JSON.stringify(g)}`)),c(i,g)}}(c,{get:e,post:r,put:n,del:o},{debug:s,fnName:u});return f({},t,{[u]:g})},{});return i}(d,{get:m,post:b,put:v,del:B},{debug:o});return!0===o&&Object.entries(w).map(([t,e])=>{console.log(`${t}: ${e.toString()}`)}),w}export{$ as default,$ as smallapi};
//# sourceMappingURL=index.modern.mjs.map
